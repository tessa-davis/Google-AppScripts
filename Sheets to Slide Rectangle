/***** SETTINGS *****/
const PRESENTATION_ID = '1NkyeYaozpEI-QBoUA7of34GhZ6M_cmjtVFmFe7f3kys';  // e.g. 1AbCDeFgHiJKlmnOPq...
const SHEET_NAME = 'Sheet1';
const COLUMN_RANGE = 'A2:A'; // Change to your data range

// Layout for the "many per slide" mode:
const PER_SLIDE = 12;       // how many rectangles per slide
const SHAPE_WIDTH = 600;    // points (72 pt = 1 inch)
const SHAPE_HEIGHT = 50;
const LEFT_MARGIN = 60;
const TOP_MARGIN = 60;
const VERTICAL_GAP = 12;

// Styling:
const FILL_COLOR = '#F5F5F5';    // any hex or theme color
const BORDER_COLOR = '#333333';
const BORDER_WEIGHT = 1;         // points
const FONT_FAMILY = 'Arial';
const FONT_SIZE_MANY = 18;       // when stacking many per slide
const FONT_SIZE_ONE = 32;        // when one per slide
const TEXT_BOLD_ONE = true;      // bold for one-per-slide mode

function createShapesFromColumn() {
  const sheet = SpreadsheetApp.getActive().getSheetByName(SHEET_NAME);
  if (!sheet) throw new Error(`Sheet "${SHEET_NAME}" not found.`);

  // Expand A2:A down to sheet's last row automatically
  const lastRow = sheet.getLastRow();
  const startA1 = COLUMN_RANGE.split(':')[0];
  const colLetter = startA1.replace(/[0-9]/g, '');
  const startRow = Number(startA1.replace(/[A-Z]/gi, '')) || 1;
  const effectiveA1 = `${colLetter}${startRow}:${colLetter}${lastRow}`;

  const values = sheet.getRange(effectiveA1).getValues()
    .map(r => (r[0] != null) ? String(r[0]).trim() : '')
    .filter(txt => txt !== '');

  console.log('Found ' + values.length + ' non-empty cells');
  if (values.length === 0) {
    SpreadsheetApp.getUi().alert('No non-empty cells found in the specified range.');
    return;
  }

  const deck = SlidesApp.openById(PRESENTATION_ID);

  // A) Many rectangles per slide (stacked)
  createRectsManyPerSlide_(deck, values);

  // B) Or comment the line above and use this for one per slide:
  // createRectsOnePerSlide_(deck, values);

  SpreadsheetApp.getUi().alert(`Done! Created ${values.length} rectangle(s).`);
}

/**
 * Shared styling for shapes (fill, border, centering, font).
 */
function styleRect_(shape, fontSize, makeBold) {
  shape.getFill().setSolidFill(FILL_COLOR);

  // âœ… Border API for shapes
  const border = shape.getBorder();
  border.setWeight(BORDER_WEIGHT);
  border.getLineFill().setSolidFill(BORDER_COLOR);

  // Text content is set by caller; this only styles/alignment:
  shape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); // vertical center
  shape.getText().getParagraphStyle()
       .setParagraphAlignment(SlidesApp.ParagraphAlignment.CENTER); // horizontal center
  const t = shape.getText().getTextStyle()
       .setFontFamily(FONT_FAMILY)
       .setFontSize(fontSize);
  if (makeBold) t.setBold(true);
}

/**
 * Creates multiple rectangle shapes per slide, stacked vertically.
 */
function createRectsManyPerSlide_(deck, values) {
  let slide = deck.getSlides()[0] || deck.appendSlide(SlidesApp.PredefinedLayout.BLANK);
  let countOnThisSlide = 0;
  let y = TOP_MARGIN;

  values.forEach(text => {
    if (countOnThisSlide >= PER_SLIDE) {
      slide = deck.appendSlide(SlidesApp.PredefinedLayout.BLANK);
      countOnThisSlide = 0;
      y = TOP_MARGIN;
    }

    const shape = slide.insertShape(
      SlidesApp.ShapeType.RECTANGLE,
      LEFT_MARGIN, y, SHAPE_WIDTH, SHAPE_HEIGHT
    );

    shape.getText().setText(text);
    styleRect_(shape, FONT_SIZE_MANY, false);

    y += SHAPE_HEIGHT + VERTICAL_GAP;
    countOnThisSlide++;
  });
}

/**
 * Creates one rectangle per slide (each value on its own slide).
 */
function createRectsOnePerSlide_(deck, values) {
  values.forEach((text, i) => {
    const slide = (i === 0 && deck.getSlides().length > 0)
      ? deck.getSlides()[0]
      : deck.appendSlide(SlidesApp.PredefinedLayout.BLANK);

    const shape = slide.insertShape(
      SlidesApp.ShapeType.RECTANGLE,
      LEFT_MARGIN, TOP_MARGIN, SHAPE_WIDTH, SHAPE_HEIGHT
    );

    shape.getText().setText(text);
    styleRect_(shape, FONT_SIZE_ONE, TEXT_BOLD_ONE);
  });
}
